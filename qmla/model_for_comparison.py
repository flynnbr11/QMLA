r"""
Model for comparison stuff

"""

import numpy as np
import scipy as sp
import os
import time
import copy
import qinfer as qi

import redis
import pickle

import qmla.redis_settings
import qmla.logging
import qmla.get_growth_rule
import qmla.database_framework

pickle.HIGHEST_PROTOCOL = 4

__all__ = [
    'ModelInstanceForComparison'
]

class ModelInstanceForComparison():
    """
    Model instances used for Bayes factor comparisons. 

    When Bayes factors are calculated remotely (ie on RQ workers),
    they require SMCUpdaters etc to do calculations.
    This class captures the minimum required to enable these calculations.
    After learning, important data from :class:`~qmla.ModelInstanceForLearning`
    is stored on the redis database. 
    This class unpickles the useful information and generates new 
    instances of the updater etc. to use in the comparison calculations.

    :param int model_id: ID of the model to study
    :param qid: ID of the QMLA instance
    :param dict qmla_core_info_database: essential details about the QMLA 
        instance needed to learn/compare models. 
        If None, this is retrieved instead from the redis database. 
    :param dict learned_model_info: result of learning, generated by 
        :meth:`~qmla.ModelInstanceForLearning.learned_info_dict`. 
    :param str host_name: name of host server on which redis database exists.
    :param int port_number: port number unique to this QMLA instance on redis database
    :param str log_file: path of QMLA instance's log file.

    """

    def __init__(
        self,
        model_id,
        qid,
        qmla_core_info_database=None,
        learned_model_info=None,
        host_name='localhost',
        port_number=6379,
        log_file='QMD_log.log',
    ):
        self.log_file = log_file
        self.qmla_id = qid
        self.model_id = model_id

        # Get essential data
        if qmla_core_info_database is None:
            redis_databases = qmla.redis_settings.get_redis_databases_by_qmla_id(
                host_name,
                port_number,
                qid
            )
            qmla_core_info_database = redis_databases['qmla_core_info_database']
            qmla_core_info_dict = pickle.loads(qmla_core_info_database.get('qmla_settings'))
            self.probes_system = pickle.loads(qmla_core_info_database['ProbeDict'])
            self.probes_simulator = pickle.loads(qmla_core_info_database['SimProbeDict'])
        else: 
            qmla_core_info_dict = qmla_core_info_database.get('qmla_settings')
            self.probes_system = qmla_core_info_database['ProbeDict']
            self.probes_simulator = qmla_core_info_database['SimProbeDict']

        # Assign attributes based on core data
        self.num_particles = qmla_core_info_dict['num_particles']
        self.probe_number = qmla_core_info_dict['num_probes']
        self.qinfer_resampler_threshold = qmla_core_info_dict['resampler_thresh']
        self.qinfer_resampler_a = qmla_core_info_dict['resampler_a']
        self.qinfer_PGH_heuristic_factor = qmla_core_info_dict['pgh_prefactor']
        self.true_model_constituent_operators = qmla_core_info_dict['true_oplist']
        self.true_model_params = qmla_core_info_dict['true_model_terms_params']
        self.true_model_name = qmla_core_info_dict['true_name']
        self.true_param_dict = qmla_core_info_dict['true_param_dict']
        self.experimental_measurements = qmla_core_info_dict['experimental_measurements']
        self.experimental_measurement_times = qmla_core_info_dict['experimental_measurement_times']
        self.results_directory = qmla_core_info_dict['results_directory']

        
        if learned_model_info is None:
            # Get data specific to this model, learned elsewhere and stored on redis database
            try:
                redis_databases = qmla.redis_settings.get_redis_databases_by_qmla_id(
                    host_name,
                    port_number,
                    qid
                )
                learned_models_info_db = redis_databases['learned_models_info_db']
            except: 
                print("Unable to retrieve redis database.")
                raise 

            model_id_str = str(float(model_id))
            try:
                learned_model_info = pickle.loads(
                    learned_models_info_db.get(model_id_str),
                    encoding='latin1'
                )
            except BaseException:
                learned_model_info = pickle.loads(
                    learned_models_info_db.get(model_id_str)
                )

        # Assign parameters from model learned info, retrieved from database
        self.model_name = learned_model_info['name']
        self.times_learned_over = learned_model_info['times_learned_over']
        self.final_learned_params = learned_model_info['final_learned_params']        
        self.growth_rule_of_this_model = learned_model_info['growth_rule_of_this_model']
        # self.model_prior = learned_model_info['final_prior']
        self.posterior_marginal = learned_model_info['posterior_marginal']
        self.model_normalization_record = learned_model_info['model_normalization_record']
        self.log_total_likelihood = learned_model_info['log_total_likelihood']
        self.estimated_mean_params = learned_model_info['estimated_mean_params']
        self.qhl_final_param_estimates = learned_model_info['qhl_final_param_estimates']
        self.qhl_final_param_uncertainties = learned_model_info['qhl_final_param_uncertainties']
        self.covariance_mtx_final = learned_model_info['covariance_mtx_final']

        # process data from learned info
        op = qmla.database_framework.Operator(self.model_name)
        self.model_terms_matrices = op.constituents_operators
        self.model_terms_parameters_final = np.array(self.final_learned_params)
        self.growth_class = qmla.get_growth_rule.get_growth_generator_class(
            growth_generation_rule=self.growth_rule_of_this_model,
            log_file=self.log_file
        )

        # New instances of model and updater used by QInfer
        self.log_print(["Getting QInfer model"])
        self.qinfer_model = self.growth_class.qinfer_model(
            model_name=self.model_name,
            modelparams=self.model_terms_parameters_final,
            oplist=self.model_terms_matrices,
            true_oplist=self.true_model_constituent_operators,
            truename=self.true_model_name,
            trueparams=self.true_model_params,
            true_param_dict = self.true_param_dict, 
            num_probes=self.probe_number,
            probe_dict=self.probes_system,
            sim_probe_dict=self.probes_simulator,
            growth_generation_rule=self.growth_rule_of_this_model,
            experimental_measurements=self.experimental_measurements,
            experimental_measurement_times=self.experimental_measurement_times,
            log_file=self.log_file,
        )
        self.log_print(["Getting QInfer updater"])
        self.reconstruct_updater = True # optionally just load it
        time_s = time.time()
        if self.reconstruct_updater:
            posterior_distribution = qi.MultivariateNormalDistribution(
                # self.qhl_final_param_estimates,
                self.estimated_mean_params,
                self.covariance_mtx_final
            )

            num_particles_for_bf = max(
                5, 
                int(self.growth_class.fraction_particles_for_bf * self.num_particles)
            ) # this allows the growth rule to use less particles for the comparison stage
            self.log_print([
                "Using {} particles for comparison.".format(num_particles_for_bf),
                "resample thresh:", self.growth_class.qinfer_resampler_threshold , 
                "resampler a:", self.growth_class.qinfer_resampler_a,
                "\nmodel=", self.qinfer_model,
                "has expparamss_dtype:", self.qinfer_model.expparams_dtype,
                "\n and posteror", posterior_distribution,
                "qhl_final_param_estimates",self.qhl_final_param_estimates

            ])

            self.qinfer_updater = qi.SMCUpdater(
                model=self.qinfer_model,
                n_particles=num_particles_for_bf,
                prior=posterior_distribution,
                zero_weight_policy='ignore', #TODO testing ignore - does it cause failures?
                # resample_thresh = self.growth_class.qinfer_resampler_threshold,
                # resampler = qi.LiuWestResampler(
                #     a=self.growth_class.qinfer_resampler_a
                # ),
                resample_thresh = self.qinfer_resampler_threshold,
                resampler = qi.LiuWestResampler(
                    a=self.qinfer_resampler_a
                ),
            )
            self.log_print(["Got QInfer updater"])
            self.qinfer_updater._normalization_record = self.model_normalization_record
            self.qinfer_updater._log_total_likelihood = self.log_total_likelihood
            time_taken = time.time() - time_s
        else:
            # Not currently pickling the updater -- can be done in ModelInstanceForLearning.learned_info_dict()
            self.qinfer_updater = pickle.loads(
                learned_model_info['updater']
            )
        self.log_print(
            [
                "Posterior mean:", self.qinfer_updater.est_mean()
            ]
        )

        # Delete extra data now that everything useful is extracted
        del qmla_core_info_dict, learned_model_info

    def log_print(
        self,
        to_print_list
    ):
        r"""Wrapper for :func:`~qmla.print_to_log`"""
        qmla.logging.print_to_log(
            to_print_list=to_print_list,
            log_file=self.log_file,
            log_identifier='ModelForComparison {}'.format(self.model_id)
        )